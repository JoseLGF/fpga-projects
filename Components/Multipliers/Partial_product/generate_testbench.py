# Testbench generator for a partial_product_multiplier
# Inputs:
# 	N - the number of bits of the partial product multiplier
# 	filename - the name of the output file that will be generated
# Outputs:
# 	A vhdl file containing a testbench to be run by ghdl or any other tool.
# Assumptions:
# This script assumes a predefined name and architecture for the component.

import sys
import math

def header(N):
	# Generates the header comments for the output file
	out = ''
	out	= "--------------------------------------------------------------------------------\n"	\
		+ "-- Generated Testbench file for " + str(N) + "bit partial product multiplier\n"	\
		+ "-- This file has been generated by 'generate_testbench.py'.\n"	\
		+ "-- DO NOT MODIFY THIS FILE MANUALLY.\n"	\
		+ "--------------------------------------------------------------------------------\n"	\
		+ "\n\n"
	return out

def libraries():
	# Generates the library imports
	out = ''
	out	= "--***********************************************\n" \
		+ "-- Required Libraries\n" \
		+ "--***********************************************\n" \
		+ "library IEEE;\n"	\
		+ "use IEEE.STD_LOGIC_1164.ALL;\n"	\
		+ "use ieee.numeric_std.all;\n"	\
		+ "\n\n"
	return out

def entityDeclaration(N):
	# Generates the entity declaration section
	entity_name = "partial_product_"\
				+ str(N)\
				+ "bit_multiplier_tb"

	out = ''
	out	= "--***********************************************\n"\
		+ "-- Entity Declaration\n"\
		+ "--***********************************************\n"\
		+ "entity " + entity_name + " is\n"\
		+ "end " + entity_name + ";\n"\
		+ "\n\n"
	return out
	
def architectureDefinition(N):
	# Generates the architecture definition section
	entity_name = "partial_product_"\
				+ str(N)\
				+ "bit_multiplier_tb"

	out = ''
	out	= "--***********************************************\n"\
		+ "-- Architecture definition\n"\
		+ "--***********************************************\n"\
		+ "architecture sim of " + entity_name + " is\n"\
		+ "\n"\
		+ componentDeclaration(N)\
		+ testSignalsDeclaration(N)\
		+ "begin\n"\
		+ "\n"\
		+ unitUnderTestInstantiation()\
		+ testProcessGeneration(N)\
		+ "end sim;\n"\
		+ "\n\n"
	return out

def componentDeclaration(N):
	# Generates the component section
	component_name	= "partial_product_"\
					+ str(N)\
					+ "bit_multiplier"
	
	max_prod = ((2**N)-1) * ((2**N)-1)
	p_bits = int(math.ceil( math.log2(max_prod) ))

	out = ''
	out	= "--***********************************************\n"\
		+ "-- Component declaration\n"\
		+ "--***********************************************\n"\
		+ "component " + component_name + " is\n"\
		+ "    port(\n"\
		+ "        a : in  std_logic_vector("\
		+ str(N-1) + " downto 0);\n"\
		+ "        b : in  std_logic_vector("\
		+ str(N-1) + " downto 0);\n"\
		+ "        p : out std_logic_vector("\
		+ str(p_bits-1) + " downto 0)\n"\
		+ "    );\n"\
		+ "end component;\n"\
		+ "\n\n"
	return out

def testSignalsDeclaration(N):
	# Generates the signals declaration
	max_prod = ((2**N)-1) * ((2**N)-1)
	p_bits = int(math.ceil( math.log2(max_prod) ))

	out = ''
	out	= "--***********************************************\n"\
		+ "-- Test signals\n"\
		+ "--***********************************************\n"\
		+ "signal s_a : std_logic_vector("\
		+ str(N-1) + " downto 0);\n"\
		+ "signal s_b : std_logic_vector("\
		+ str(N-1) + " downto 0);\n"\
		+ "signal s_p : std_logic_vector("\
		+ str(p_bits-1) + " downto 0);\n"\
		+ "\n\n"
	return out

def unitUnderTestInstantiation():
	# Generates the UUT port map
	component_name	= "partial_product_"\
					+ str(N)\
					+ "bit_multiplier"

	out = ''
	out	= "--***********************************************\n"\
		+ "-- Component instantiation\n"\
		+ "--***********************************************\n"\
		+ "UUT : " + component_name+ " \n"\
		+ "port map(\n"\
		+ "    a => s_a,\n"\
		+ "    b => s_b,\n"\
		+ "    p => s_p\n"\
		+ ");\n"\
		+ "\n\n"
	return out
	
def testProcessGeneration(N):
	# Generates test process
	out = ''
	out	= "--***********************************************\n"\
		+ "-- Test process\n"\
		+ "--***********************************************\n"\
		+ "process begin\n"\
		+ 'assert false report "Running autogenerated test file." severity note;\n'\
		+ generateTestCases(N)\
		+ 'assert false report "All tests have been executed." severity note;\n'\
		+ 'wait;\n'\
		+ "end process;\n"\
		+ "\n\n"
	return out	
	
def generateTestCases(N):
	# Generates all possible inputs values
	# and their assert statements
	max_input_value = 2**N - 1
	max_prod = ((2**N)-1) * ((2**N)-1)
	p_bits = int(math.ceil( math.log2(max_prod) ))
	
	out = ''
	for x in range (0, max_input_value+1):
		for y in range (0, max_input_value+1):
			p = x * y
			out = out \
				+ "s_a <= " +NbitBinary(x, N) + "; -- " + str(x) + "\n"\
				+ "s_b <= " +NbitBinary(y, N) + "; -- " + str(y) + "\n"\
				+ "-- p = " + str(p) + "\n"\
				+ "wait for 5 ns; \n"\
				+ "assert s_p = " + NbitBinary(p, p_bits)\
				+ ' report "Error, test failed" severity failure;\n'
	return out	
	
def NbitBinary(n,b):
	# returns a string representation of 
	# an integer n as binary with b bits
    out = ''
    for i in range(b):
        if (n%2 == 1):
            out += '1'
        else:
            out += '0'
        n = int(n/2)
    return '"' + out[::-1] + '"'
	
# -----------------------------------------------------------------------------
# Program start
# -----------------------------------------------------------------------------
# Take exactly two parameters
if not (len(sys.argv) == 3):
	print("Error, wrong number of arguments provided")
	exit(1)

# Arguments check
N			= int(sys.argv[1])
filename	= sys.argv[2]
if N < 2:
	print("Error, N value must be at least 2 to generate properly.")
	exit(1)

# Generate output string
outStr = ''
outStr	=	header(N)					\
		+	libraries()					\
		+	entityDeclaration(N)		\
		+	architectureDefinition(N)	\

# write output string to vhdl file
with open(filename, 'w') as f: 
	f.write(outStr)

print("File generation completed. File written to " \
	+ filename)
