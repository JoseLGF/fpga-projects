# Component generator for an n bit partial product multiplier
# Inputs:
# 	N - the number of bits of the partial product multiplier
# 	filename - the name of the output file that will be generated
# Outputs:
# 	A vhdl file containing a testbench to be run by ghdl or any other tool.
# Assumptions:
# This script assumes a predefined name and architecture for the component.

import sys
import math

def header(N):
	# Generates the header comments for the output file
	out = ''
	out	= "--------------------------------------------------------------------------------\n"\
		+ "-- Generated Component file for " + str(N) + "bit partial product multiplier\n"\
		+ "-- This file has been generated by 'generate_ppm_nbit.py'.\n"\
		+ "-- DO NOT MODIFY THIS FILE MANUALLY.\n"\
		+ "--------------------------------------------------------------------------------\n"\
		+ "\n\n"
	return out

def libraries():
	# Generates the library imports
	out = ''
	out	= "--***********************************************\n" \
		+ "-- Required Libraries\n" \
		+ "--***********************************************\n" \
		+ "library IEEE;\n"	\
		+ "use IEEE.STD_LOGIC_1164.ALL;\n"	\
		+ "use ieee.numeric_std.all;\n"	\
		+ "use ieee.numeric_bit.all;\n"	\
		+ "\n\n"
	return out

def entityDeclaration(N):
	# Generates the entity declaration section
	entity_name = "partial_product_"\
				+ str(N)\
				+ "bit_multiplier"
	max_prod = ((2**N)-1) * ((2**N)-1)
	p_bits = int(math.ceil( math.log2(max_prod) ))

	out = ''
	out	= "--***********************************************\n"\
		+ "-- entity declaration\n"\
		+ "--***********************************************\n"\
		+ "entity " + entity_name + " is\n"\
		+ "    port(\n"\
		+ "        a : in  std_logic_vector("\
		+ str(N-1) + " downto 0);\n"\
		+ "        b : in  std_logic_vector("\
		+ str(N-1) + " downto 0);\n"\
		+ "        p : out std_logic_vector("\
		+ str(p_bits-1) + " downto 0)\n"\
		+ "    );\n"\
		+ "end entity;\n"\
		+ "\n\n"
	return out
	
def architectureDefinition(N):
	# Generates the architecture definition section
	entity_name = "partial_product_"\
				+ str(N)\
				+ "bit_multiplier"

	
	# precalculating the signals and adders that will be needed later
	# Get all the sums of products
	sums = calculateSumsOfProducts(N)
	adders, signals = convertSumsIntoAdders(sums)
	
	# Code generation
	out = ''
	out	= "--***********************************************\n"\
		+ "-- Architecture definition\n"\
		+ "--***********************************************\n"\
		+ "architecture combinational of " + entity_name + " is\n"\
		+ "\n"\
		+ componentDeclaration(N)\
		+ testSignalsDeclaration(N)\
		+ componentSignalsDeclaration(signals)\
		+ "begin\n"\
		+ "\n"\
		+ generateProductsAssignments(N)\
		+ componentsInstantiation(adders)\
		+ "end combinational;\n"\
		+ "\n\n"
	return out

def componentDeclaration(N):
	# Generates the component section
	out = ''
	out	= "--***********************************************\n"\
		+ "-- Components declaration\n"\
		+ "--***********************************************\n"\
		+ "component half_adder is\n"\
		+ "    port(\n"\
		+ "        a     : in  std_logic;\n"\
		+ "        b     : in  std_logic;\n"\
		+ "        sum   : out std_logic;\n"\
		+ "        carry : out std_logic\n"\
		+ "    );\n"\
		+ "end component;\n"\
		+ "\n"\
		+ "component full_adder is\n"\
		+ "    port(\n"\
		+ "        a     : in  std_logic;\n"\
		+ "        b     : in  std_logic;\n"\
		+ "        cin   : in  std_logic;\n"\
		+ "        sum   : out std_logic;\n"\
		+ "        cout  : out std_logic\n"\
		+ "    );\n"\
		+ "end component;\n"\
		+ "\n\n"
	return out

def testSignalsDeclaration(N):
	# Generates the signals declaration
	max_prod = ((2**N)-1) * ((2**N)-1)
	p_bits = int(math.ceil( math.log2(max_prod) ))

	out = ''
	out	= "--***********************************************\n"\
		+ "-- internal signals\n"\
		+ "--***********************************************\n"\
		+ generateProductsSignals(N)\
		+ "\n\n"
	return out

def componentSignalsDeclaration(signals):
	# Generates the signals for the component port maps
	
	signals_str = ''
	for signal in signals:
		signals_str = signals_str \
			+ "signal " + signal + " : std_logic;\n"
	
	out = ''
	out	= "--***********************************************\n"\
		+ "-- Component signals\n"\
		+ "--***********************************************\n"\
		+ signals_str\
		+ "\n\n"
	return out

def generateProductsSignals(N):
	signals = []
	# returns a list with all input products
	for a in range (0, N):
		for b in range (0, N):
			signals.append("a"+str(a)+"b"+str(b))
	
	out = ''
	for signal in signals:
		out = out \
			+ "signal " + signal + " : std_logic;\n"
	return out

def componentsInstantiation(addersLists):
	# Generates the port mappings of all components
	
	out = ''
	out	= "--***********************************************\n"\
		+ "-- Component instantiation\n"\
		+ "--***********************************************\n"
	
	counter = 0
	for adderList in addersLists:
		for adder in adderList:
			out = out + generateAdder(adder, counter)
			counter += 1
		
	out = out + "\n\n"
	return out

def generateAdder(adder, counter):
	# generates the code for an adder, given its connections
	
	print("Generating adder:")
	print(adder)

	# if in_3 in the adder is not empty, it's a full adder
	if adder['in_3']:
		return generateFullAdder(adder, counter)
	
	# if in_2 in the adder is not empty, it's a half adder
	if adder["in_2"]:
		return generateHalfAdder(adder, counter)
	
	# If not a full nor half adder, it is a direct connection
	return generateDirectConnection(adder, counter)

def generateFullAdder(adder, counter):
	# Generates the code for a full adder
	out = ''
	out = out \
		+ "fa_" + str(counter) + " : full_adder \n"\
		+ "port map(\n"\
		+ "    a    => " + adder["in_1"]  + ",\n"\
		+ "    b    => " + adder["in_2"]  + ",\n"\
		+ "    cin  => " + adder["in_3"]  + ",\n"\
		+ "    sum  => " + adder["sum"]   + ",\n"\
		+ "    cout => " + adder["carry"] + "\n"\
		+ ");\n"\
		+ "\n"
	return out

def generateHalfAdder(adder, counter):
	# Generates the code for a half adder
	out = ''
	out = out \
		+ "ha_" + str(counter) + " : half_adder \n"\
		+ "port map(\n"\
		+ "    a     => " + adder["in_1"]  + ",\n"\
		+ "    b     => " + adder["in_2"]  + ",\n"\
		+ "    sum   => " + adder["sum"]   + ",\n"\
		+ "    carry => " + adder["carry"] + "\n"\
		+ ");\n"\
		+ "\n"
	return out

def generateDirectConnection(adder, counter):
	# Generates the code for a half adder
	out = ''
	out = out \
		+ "p(" + str(adder["level"]) + ") <= " + adder["in_1"] + ";\n"\
		+ "\n"
	return out

def convertSumsIntoAdders(sums):
	# Converts the list of sums into a list
	# of full adders and half adders
	
	# adder structure:
	# {
	#	in_1
	#	in_2
	#	in_3
	#	sum
	#	carry
	#	adder_level
	# }
	
	
	adders = []
	for i in range (0, len(sums)+1):
		adders.append([])
		signals = []
	# iterate each level
	adder_counter = 0
	for index in range(0, len(sums)):
		level = sums[index]
		print(level)
		while len(level) > 0:
			print(len(level))
			if len(level) == 1:
				adders[index].append({		\
								"in_1"  : level[0],\
								"in_2"  : '',\
								"in_3"  : '',\
								"sum"   : '',\
								"carry" : '',\
								"level" : index,\
								})
				level.pop(0)
			elif len(level) == 2:
				adders[index].append({\
								"in_1"  : level[0],\
								"in_2"  : level[1],\
								"in_3"  : '',\
								"sum"   : "s_a"+str(adder_counter),\
								"carry" : "c_a"+str(adder_counter),\
								"level" : index,\
								})
				signals.append("s_a"+str(adder_counter))
				signals.append("c_a"+str(adder_counter))
				sums[index].append("s_a"+str(adder_counter))
				sums[index+1].append("c_a"+str(adder_counter))
				level.pop(0)
				level.pop(0)
				adder_counter = adder_counter + 1
			else:
				adders[index].append({\
								"in_1"  : level[0],\
								"in_2"  : level[1],\
								"in_3"  : level[2],\
								"sum"   : "s_a"+str(adder_counter),\
								"carry" : "c_a"+str(adder_counter),\
								"level" : index,\
								})
				signals.append("s_a"+str(adder_counter))
				signals.append("c_a"+str(adder_counter))
				sums[index].append("s_a"+str(adder_counter))
				sums[index+1].append("c_a"+str(adder_counter))
				level.pop(0)
				level.pop(0)
				level.pop(0)
				adder_counter = adder_counter + 1
	
	for i in range (0, len(sums)):
		print(str(len(adders[i])) + str(adders[i]))
	
	for signal in signals:
		print(signal)
	
	return adders, signals
	
def generateTestCases(N):
	# Generates all possible inputs values
	# and their assert statements
	max_input_value = 2**N - 1
	max_prod = ((2**N)-1) * ((2**N)-1)
	p_bits = int(math.ceil( math.log2(max_prod) ))
	
	out = ''
	for x in range (0, max_input_value+1):
		for y in range (0, max_input_value+1):
			p = x * y
			out = out \
				+ "s_a <= " +NbitBinary(x, N) + "; -- " + str(x) + "\n"\
				+ "s_b <= " +NbitBinary(y, N) + "; -- " + str(y) + "\n"\
				+ "-- p = " + str(p) + "\n"\
				+ "wait for 5 ns; \n"\
				+ "assert s_p = " + NbitBinary(p, p_bits)\
				+ ' report "Error, test failed" severity failure;\n'
	return out	
	
def NbitBinary(n,b):
	# returns a string representation of 
	# an integer n as binary with b bits
    out = ''
    for i in range(b):
        if (n%2 == 1):
            out += '1'
        else:
            out += '0'
        n = int(n/2)
    return '"' + out[::-1] + '"'

def calculateSumsOfProducts(N):
	# returns a list of lists, with the sums of products
	# required for every bit in the multiplication
	max_input_value = 2**N - 1
	max_prod = ((2**N)-1) * ((2**N)-1)
	p_bits = int(math.ceil( math.log2(max_prod) ))
	
	sums = []
	for i in range (0, p_bits):
		sums.append([])
	
	for a in range (0, N):
		for b in range (0, N):
			sums[a+b].append("a"+str(a)+"b"+str(b))
			
	return sums
	
def generateProductsAssignments(N):
	# Generates all the assignments for the products
	out = ''
	out = out \
	+ "--***********************************************\n"\
	+ "-- Products assignments\n"\
	+ "--***********************************************\n"\
	
	# returns a list with all input products
	for a in range (0, N):
		for b in range (0, N):
			out = out \
				+ "a"+str(a)+"b"+str(b) \
				+ " <= a(" + str(a) + ") and b(" + str(b) + ");\n"
	out = out \
	+ "\n\n"
	return out
	
# -----------------------------------------------------------------------------
# Program start
# -----------------------------------------------------------------------------
# Take exactly two parameters
if not (len(sys.argv) == 3):
	print("Error, wrong number of arguments provided")
	exit(1)

# Arguments check
N			= int(sys.argv[1])
filename	= sys.argv[2]
if N < 2:
	print("Error, N value must be at least 2 to generate properly.")
	exit(1)

# Generate output string
outStr = ''
outStr	=	header(N)					\
		+	libraries()					\
		+	entityDeclaration(N)		\
		+	architectureDefinition(N)	\

# write output string to vhdl file
with open(filename, 'w') as f: 
	f.write(outStr)

print("File generation completed. File written to " \
	+ filename)
